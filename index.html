<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Hand-Tracked Art</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121923;
      --ink: #e6f0ff;
      --muted: #7c8aa0;
      --accent: #6aa6ff;
      --ok: #4ade80;
      --warn: #f59e0b;
      --err: #ef4444;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 70% -10%, #162232 0%, var(--bg) 60%);
      color: var(--ink);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
      background: color-mix(in oklab, var(--panel) 86%, #000 14%);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .controls {
      margin-left: auto;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls label { color: var(--muted); font-size: 13px; }
    .controls select, .controls input[type="range"], .controls button {
      background: #0f1520;
      border: 1px solid #243244;
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      outline: none;
    }
    .controls input[type="range"]{ height: 32px; }
    .controls button {
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;
    }
    .controls button:hover { border-color: #31507a; }
    .controls button:active { transform: translateY(1px) scale(0.99); }

    .wrap {
      position: relative;
      min-height: 0;
      height: calc(100vh - 120px);
      display: grid;
      grid-template-columns: 1fr min(28vw, 360px);
      gap: 12px;
      padding: 12px;
    }

    canvas#art {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(800px 500px at 50% 40%, #0d1522, #0a0e14);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.38) inset, 0 6px 18px rgba(0,0,0,0.3);
    }

    .side {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 12px;
    }
    .panel {
      background: #0e141e;
      border: 1px solid #1d2a3a;
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.28);
    }

    .preview {
      position: relative;
      aspect-ratio: 3 / 4;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #1a2534;
    }
    video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    canvas#hud { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    footer { color: var(--muted); padding: 8px 14px; font-size: 12px; }
    .badge { font-variant-numeric: tabular-nums; padding: 2px 8px; border-radius: 999px; border: 1px solid #2a3b52; margin-left: 6px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body>
  <header>
    <h1>Interactive Hand‑Tracked Art <span id="status" class="badge">booting…</span></h1>
    <div class="controls">
      <label>Dominant hand
        <select id="handedness">
          <option value="any">Auto</option>
          <option value="Right">Right</option>
          <option value="Left">Left</option>
        </select>
      </label>
      <label>Hover radius
        <input id="radius" type="range" min="10" max="120" value="48" />
      </label>
      <button id="shuffle">Shuffle Art</button>
      <button id="clear">Reset</button>
    </div>
  </header>

  <div class="wrap">
    <canvas id="art"></canvas>

    <div class="side">
      <div class="panel">
        <div class="preview">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="hud"></canvas>
        </div>
      </div>

      <div class="panel" style="display:grid; gap:6px; align-content:start;">
        <div><strong>How it works</strong></div>
        <div class="muted">Allow camera access. Move your hand in front of the camera. Hover over shapes with your index fingertip or palm to trigger effects. Use the dropdown to target a specific hand, if desired.</div>
        <div class="muted">Tips: ensure good lighting; keep hand within frame. This runs entirely in your browser.</div>
      </div>
    </div>
  </div>

  <footer>
    <span>Model: MediaPipe Hands</span>
    <span class="badge mono" id="perf">– ms</span>
  </footer>

  <!-- MediaPipe dependencies (served via jsDelivr CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    // --- DOM refs ---
    const art = document.getElementById('art');
    const ctx = art.getContext('2d');
    const hud = document.getElementById('hud');
    const hctx = hud.getContext('2d');
    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const perfEl = document.getElementById('perf');
    const radiusEl = document.getElementById('radius');
    const handednessEl = document.getElementById('handedness');
    const shuffleBtn = document.getElementById('shuffle');
    const clearBtn = document.getElementById('clear');

    // --- Canvas sizing ---
    function fitCanvasToDisplay() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = art.getBoundingClientRect();
      art.width = Math.floor(rect.width * dpr);
      art.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const prect = hud.getBoundingClientRect();
      hud.width = Math.floor(prect.width * dpr);
      hud.height = Math.floor(prect.height * dpr);
      hctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', fitCanvasToDisplay);
    fitCanvasToDisplay();

    // --- Art primitives ---
    const shapes = [];
    const palette = ['#6aa6ff','#8b5cf6','#22d3ee','#f472b6','#f59e0b','#4ade80'];
    const rnd = (a,b)=>Math.random()*(b-a)+a;
    const irnd = (a,b)=>Math.floor(rnd(a,b));

    function seedArt(count = 40) {
      shapes.length = 0;
      const { width: W, height: H } = art.getBoundingClientRect();
      for (let i=0;i<count;i++) {
        const type = Math.random()<0.4 ? 'circle' : (Math.random()<0.5?'poly':'rect');
        const s = {
          id: i,
          type,
          x: rnd(40, W-40),
          y: rnd(40, H-40),
          r: rnd(12, 38),
          w: rnd(24, 86),
          h: rnd(24, 86),
          rot: rnd(0, Math.PI*2),
          hue: palette[irnd(0,palette.length)],
          baseHue: null,
          vx: rnd(-0.3, 0.3),
          vy: rnd(-0.3, 0.3),
          spin: rnd(-0.02, 0.02),
          jitter: rnd(0.5, 1.5),
          pulse: rnd(0.8, 1.2),
          hover: 0,
        };
        s.baseHue = s.hue;
        shapes.push(s);
      }
    }

    function drawShapes(dt, pointer) {
      const { width: W, height: H } = art.getBoundingClientRect();
      ctx.clearRect(0,0,W,H);

      // Ambient background sparkles
      for (let i=0;i<80;i++) {
        const x = (i*97) % W; const y = (i*71) % H; const a = ((i*13)%100)/200 + 0.05;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect((x + i*dt*0.02)%W, (y + i*dt*0.03)%H, 1, 1);
      }

      const hoverRadius = +radiusEl.value;

      shapes.forEach(s => {
        // Motion update
        s.x += s.vx * s.jitter;
        s.y += s.vy * s.jitter;
        s.rot += s.spin;
        if (s.x < 20 || s.x > W-20) s.vx *= -1;
        if (s.y < 20 || s.y > H-20) s.vy *= -1;

        // Interaction
        if (pointer) {
          const dx = s.x - pointer.x;
          const dy = s.y - pointer.y;
          const d = Math.hypot(dx, dy);
          const inside = d < hoverRadius + s.r;
          s.hover = Math.max(0, Math.min(1, inside ? 1 - (d/(hoverRadius+s.r)) : s.hover*0.92));
          if (inside) {
            // Repel a bit
            s.x += (dx / (d+0.0001)) * 1.8;
            s.y += (dy / (d+0.0001)) * 1.8;
            // Color shift + pulse
            s.hue = '#ffffff';
          } else {
            s.hue = s.baseHue;
          }
        } else {
          s.hover *= 0.94;
          s.hue = s.baseHue;
        }

        // Draw
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rot);
        const scale = 1 + s.hover * 0.35;
        ctx.scale(scale, scale);
        ctx.globalAlpha = 0.88 + s.hover*0.12;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.fillStyle = s.hue;

        if (s.type === 'circle') {
          ctx.beginPath();
          ctx.arc(0, 0, s.r, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
        } else if (s.type === 'rect') {
          roundedRect(ctx, -s.w/2, -s.h/2, s.w, s.h, 10);
          ctx.fill();
          ctx.stroke();
        } else { // poly (triangle-ish)
          const R = s.r * 1.2;
          ctx.beginPath();
          for (let i=0;i<5;i++) {
            const a = i * (Math.PI*2/5);
            const px = Math.cos(a) * R;
            const py = Math.sin(a) * R * (i%2?0.55:1);
            if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      });

      // Pointer visualization
      if (pointer) {
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(pointer.x, pointer.y, hoverRadius, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.16)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
    }

    function roundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    // --- Hand tracking via MediaPipe Hands ---
    let latestPointer = null; // {x,y}
    let lastStamp = performance.now();

    function toCanvasCoords(normX, normY) {
      // normX/normY are 0..1 in video space; map to hud canvas first (mirrored), then to art canvas proportionally
      const prect = hud.getBoundingClientRect();
      const xHud = (1 - normX) * prect.width; // mirror to match UI
      const yHud = normY * prect.height;

      const arect = art.getBoundingClientRect();
      // Map proportionally (both canvases are same pixel ratio scaling already)
      const xArt = xHud / prect.width * arect.width;
      const yArt = yHud / prect.height * arect.height;
      return { x: xArt, y: yArt };
    }

    function pickPointerFromLandmarks(result) {
      // Prefer index fingertip if visible; else use palm center approximation
      const lm = result.landmarks;
      if (!lm || lm.length === 0) return null;
      const tip = lm[8]; // index fingertip
      if (tip && tip.visibility === undefined || tip.visibility > 0.5) {
        return toCanvasCoords(tip.x, tip.y);
      }
      // Approx palm center as avg of wrist(0) + MCPs(5,9,13,17)
      const ids = [0,5,9,13,17];
      const mean = ids.reduce((acc, id)=>({x: acc.x+lm[id].x, y: acc.y+lm[id].y}), {x:0,y:0});
      mean.x /= ids.length; mean.y /= ids.length;
      return toCanvasCoords(mean.x, mean.y);
    }

    // HUD drawing of detected hands for debug
    function drawHUD(results) {
      const prect = hud.getBoundingClientRect();
      hctx.clearRect(0,0,prect.width, prect.height);
      if (!results || results.multiHandLandmarks.length === 0) return;
      for (let i = 0; i < results.multiHandLandmarks.length; i++) {
        const landmarks = results.multiHandLandmarks[i];
        window.drawConnectors(hctx, landmarks, window.HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.25)'});
        window.drawLandmarks(hctx, landmarks, {color: '#ffffff', fillColor: '#ffffff', radius: 1.5});
      }
    }

    // Filter by handedness per user selection
    function selectHand(results) {
      const pref = handednessEl.value; // 'any' | 'Left' | 'Right'
      const list = [];
      for (let i=0; i<results.multiHandedness.length; i++) {
        const meta = results.multiHandedness[i];
        if (pref === 'any' || meta.label === pref) {
          list.push({ landmarks: results.multiHandLandmarks[i], label: meta.label, score: meta.score });
        }
      }
      return list;
    }

    // --- Main loop ---
    let hands = null;
    let cam = null;

    async function init() {
      try {
        statusEl.textContent = 'requesting camera…';
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }, audio: false });
        video.srcObject = stream;
      } catch (err) {
        statusEl.textContent = 'camera blocked';
        console.error(err);
        alert('Camera permission is required. Please allow access and reload.');
        return;
      }

      hands = new window.Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });

      hands.onResults((results) => {
        // Keep a lightweight, filtered representation
        if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
          const picked = selectHand(results);
          const focus = picked[0];
          latestPointer = focus ? pickPointerFromLandmarks(focus) : null;
        } else {
          latestPointer = null;
        }
        drawHUD(results);
      });

      cam = new window.Camera(video, {
        onFrame: async () => {
          const t0 = performance.now();
          await hands.send({ image: video });
          perfEl.textContent = `${Math.round(performance.now() - t0)} ms`;
        },
        width: 640,
        height: 480,
      });
      cam.start();

      statusEl.textContent = 'live';
      seedArt();
      requestAnimationFrame(tick);
    }

    function tick(now) {
      const dt = Math.min(33, now - lastStamp); // cap delta for stability
      lastStamp = now;
      drawShapes(dt, latestPointer);
      requestAnimationFrame(tick);
    }

    // --- UI wiring ---
    shuffleBtn.addEventListener('click', () => seedArt(irnd(30, 70)));
    clearBtn.addEventListener('click', () => seedArt());

    // Kick things off
    init();
  </script>
</body>
</html>
