<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandTouch — Camera Hand Tracking Interactive Screen</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#10141a; --ink:#e9eef6; --muted:#8ea1b8; --accent:#78e3ff; --accent2:#b6ff7d;
      --card:#0f141a; --border:#1c2533; --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:linear-gradient(180deg,var(--bg),#0e1217); color:var(--ink); font:14px/1.4 system-ui, -apple-system, Segoe UI, Inter, Roboto, sans-serif}

    .wrap{display:grid; grid-template-rows:auto 1fr auto; height:100vh}
    header{display:flex; align-items:center; gap:.6rem; padding:.55rem .8rem; background:rgba(0,0,0,.28); border-bottom:1px solid var(--border); backdrop-filter:saturate(1.2) blur(6px)}
    header h1{margin:0; font-size:14px; font-weight:650; letter-spacing:.3px}
    .pill{padding:.18rem .55rem; border:1px solid var(--border); border-radius:999px; color:var(--muted)}

    .stage{position:relative; display:grid; place-items:center; overflow:hidden}
    video, canvas{position:absolute; inset:0; width:100%; height:100%}
    video{object-fit:cover; filter:brightness(.96) contrast(1.05) saturate(1.05)}

    .toolbar{position:absolute; left:12px; top:12px; display:flex; gap:8px; flex-wrap:wrap; background:var(--panel); border:1px solid var(--border); padding:10px; border-radius:14px; box-shadow:var(--shadow)}
    .btn{appearance:none; border:1px solid var(--border); background:#131923; color:#d9e3f1; padding:8px 10px; border-radius:10px; cursor:pointer; transition:transform .08s ease, background .15s ease, border .15s ease}
    .btn:hover{transform:translateY(-1px)}
    .btn[aria-pressed="true"]{background:#172236; border-color:#26344b}
    .row{display:flex; gap:8px; align-items:center}
    .legend{position:absolute; right:12px; bottom:12px; background:var(--panel); border:1px solid var(--border); padding:10px 12px; border-radius:12px; color:#c7cfdb; max-width:min(420px, 56vw); box-shadow:var(--shadow)}
    .legend b{color:#eaf1ff}
    .hidden{display:none}

    footer{display:flex; justify-content:space-between; align-items:center; padding:.5rem .8rem; color:#97a3b7; background:rgba(0,0,0,.25); border-top:1px solid var(--border)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>HandTouch</h1>
      <span class="pill" id="status">Loading…</span>
      <span class="pill" id="fps">0 fps</span>
      <span class="pill" id="handed">auto</span>
      <div class="row" style="margin-left:auto">
        <button class="btn" id="flip">Flip Camera</button>
        <button class="btn" id="toggleCam" aria-pressed="true">Camera On</button>
        <label class="btn" for="overlayToggle"><input id="overlayToggle" type="checkbox"> Landmarks</label>
      </div>
    </header>

    <main class="stage" id="stage">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="scene"></canvas>
      <canvas id="overlay" class="hidden"></canvas>

      <section class="toolbar" role="toolbar" aria-label="Options">
        <div class="row">
          <button class="btn" id="anim">Toggle Animation</button>
          <button class="btn" id="reset">Reset</button>
          <label class="btn" for="prefLeft">
            <input id="prefLeft" type="radio" name="handPref" value="left"> Left
          </label>
          <label class="btn" for="prefRight">
            <input id="prefRight" type="radio" name="handPref" value="right"> Right
          </label>
          <label class="btn" for="prefAuto">
            <input id="prefAuto" type="radio" name="handPref" value="auto" checked> Auto
          </label>
        </div>
      </section>

      <aside class="legend">
        <div style="font-weight:600; margin-bottom:6px">How to interact</div>
        <div>• Hover fingertip over objects to highlight</div>
        <div>• Tap (quick in/out) to trigger buttons</div>
        <div>• Pinch near the ball to grab & drag</div>
        <div style="margin-top:6px; color:#8ea2bf">Tip: Use Flip if your camera is mirrored.</div>
      </aside>
    </main>

    <footer>
      <div>On‑device hand tracking via MediaPipe Hands.</div>
      <div id="hint">Allow camera to begin.</div>
    </footer>
  </div>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

    const els = {
      video: document.getElementById('video'),
      scene: document.getElementById('scene'),
      overlay: document.getElementById('overlay'),
      stage: document.getElementById('stage'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      hint: document.getElementById('hint'),
      flip: document.getElementById('flip'),
      toggleCam: document.getElementById('toggleCam'),
      overlayToggle: document.getElementById('overlayToggle'),
      animBtn: document.getElementById('anim'),
      resetBtn: document.getElementById('reset'),
      handed: document.getElementById('handed'),
      prefLeft: document.getElementById('prefLeft'),
      prefRight: document.getElementById('prefRight'),
      prefAuto: document.getElementById('prefAuto'),
    };

    const dctx = els.scene.getContext('2d');
    const octx = els.overlay.getContext('2d');

    function fitCanvases(){
      const r = els.stage.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio||1);
      [els.scene, els.overlay].forEach(c=>{ c.width = Math.floor(r.width*dpr); c.height = Math.floor(r.height*dpr); c.style.width = r.width+'px'; c.style.height = r.height+'px'; });
      dctx.setTransform(dpr,0,0,dpr,0,0);
      octx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', fitCanvases); fitCanvases();

    // Camera
    let stream=null; const state={ camFacing:'user', camOn:true };
    async function startCamera(){
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video:{facingMode:state.camFacing, width:{ideal:1280}, height:{ideal:720}}, audio:false });
        els.video.srcObject=stream; els.hint.textContent='Point your index finger at the screen.';
      }catch(e){ els.hint.textContent='Camera blocked. Enable it in browser settings.'; console.error(e); }
    }
    function stopCamera(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } els.video.srcObject=null; }
    els.flip.onclick = async()=>{ state.camFacing = (state.camFacing==='user'?'environment':'user'); await stopCamera(); await startCamera(); };
    els.toggleCam.onclick = async()=>{ state.camOn=!state.camOn; els.toggleCam.setAttribute('aria-pressed', String(state.camOn)); els.toggleCam.textContent=state.camOn?'Camera On':'Camera Off'; if(state.camOn) startCamera(); else stopCamera(); };
    await startCamera();

    // MediaPipe Hands
    els.status.textContent='Loading model…';
    const fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
    const handLandmarker = await HandLandmarker.createFromOptions(fileset,{
      baseOptions:{ modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
      numHands:2, runningMode:'VIDEO'
    });
    els.status.textContent='Ready';

    const LM={ WRIST:0, INDEX_TIP:8, THUMB_TIP:4 };
    let handPref='auto'; let lastHanded='auto';
    [els.prefLeft,els.prefRight,els.prefAuto].forEach(r=> r.addEventListener('change', ()=>{ handPref = (document.querySelector('input[name="handPref"]:checked')?.value || 'auto'); }));

    function chooseHand(result){
      const hands = result.handednesses || [];
      if(hands.length===0) return null;
      if(handPref==='auto') return 0; // pick first
      for(let i=0;i<hands.length;i++){
        const label = hands[i][0]?.categoryName?.toLowerCase();
        if(label===handPref) return i;
      }
      return 0;
    }

    // Interaction helpers
    function normToCanvas(pt){ const r = els.scene.getBoundingClientRect(); return { x: pt.x*r.width, y: pt.y*r.height } }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy) }
    function pinchValue(lms){ const a=lms[LM.THUMB_TIP], b=lms[LM.INDEX_TIP]; if(!a||!b) return 1; const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy) }

    let fpsSmoothed=0, lastT=performance.now();
    function updateFPS(t){ const dt=Math.max(1,t-lastT); lastT=t; const fps=1000/dt; fpsSmoothed=fpsSmoothed*0.9+fps*0.1; els.fps.textContent=fpsSmoothed.toFixed(0)+' fps'; }

    // Scene objects
    const scene={ bg:'#0c1117', targetBg:'#0c1117', anim:false, particles:[],
      objects:[]
    };

    // Interactive objects API
    class Obj{ constructor(type,x,y){ this.type=type; this.x=x; this.y=y; this.r=28; this.hover=false; this.pressed=false; this.color='#fff'; }
      contains(p){ return dist(this,p) <= this.r }
      draw(ctx){ ctx.save(); ctx.translate(this.x,this.y); if(this.type==='color'){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=this.hover? '#ffffffaa':'#00000055'; ctx.stroke(); }
        else if(this.type==='button'){ ctx.fillStyle=this.hover?'#1e2a3d':'#162032'; roundRect(ctx,-44,-18,88,36,10); ctx.fill(); ctx.strokeStyle='#24354e'; ctx.stroke(); ctx.fillStyle='#d9e3f1'; ctx.font='600 13px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('Toggle',0,0); }
        else if(this.type==='ball'){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=this.hover? '#ffffffaa':'#00000055'; ctx.stroke(); }
        ctx.restore(); }
      onTap(){ /* default no-op */ }
    }

    function roundRect(ctx,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

    // Build scene
    const colors=['#78e3ff','#b6ff7d','#ffd166','#ff6b6b','#c792ea','#9be7ff'];
    colors.forEach((c,i)=>{ const o=new Obj('color', 70+i*56, 70); o.color=c; o.onTap=()=>{ scene.targetBg=c + '22'; }; scene.objects.push(o); });
    const btn=new Obj('button', 70, 140); btn.onTap=()=>{ scene.anim=!scene.anim; }; scene.objects.push(btn);
    const ball=new Obj('ball', 180, 140); ball.r=34; ball.color='#66d9e8'; ball.isGrabbed=false; scene.objects.push(ball);

    // Particles for animation
    function spawnParticles(n){ for(let i=0;i<n;i++){ scene.particles.push({ x:Math.random()*els.scene.width, y:Math.random()*els.scene.height, vx:(Math.random()-0.5)*1.2, vy:(Math.random()-0.5)*1.2, r:2+Math.random()*3, a:0.3+Math.random()*0.6 }); } }
    spawnParticles(140);

    // Tap detection
    let lastTouchState=false; let lastTouchTime=0; let lastTip={x:0,y:0};

    function render(){
      // Smooth bg
      dctx.save(); dctx.fillStyle=scene.bg; dctx.fillRect(0,0,els.scene.width,els.scene.height); dctx.restore();

      // Animate bg color toward target
      scene.bg = lerpColor(scene.bg, scene.targetBg, 0.05);

      // Particles
      if(scene.anim){
        dctx.save(); dctx.globalAlpha=0.8; dctx.fillStyle='#ffffff05'; dctx.fillRect(0,0,els.scene.width,els.scene.height); dctx.restore();
        dctx.save(); dctx.globalAlpha=0.7; dctx.fillStyle='#ffffff';
        for(const p of scene.particles){ p.x+=p.vx; p.y+=p.vy; if(p.x<0||p.x>els.scene.width) p.vx*=-1; if(p.y<0||p.y>els.scene.height) p.vy*=-1; dctx.beginPath(); dctx.arc(p.x,p.y,p.r,0,Math.PI*2); dctx.globalAlpha=p.a; dctx.fill(); }
        dctx.restore();
      }

      // Objects
      for(const o of scene.objects){ o.draw(dctx); }

      requestAnimationFrame(render);
    }

    function lerp(a,b,t){ return a+(b-a)*t }
    function lerpColor(c1,c2,t){ if(!c2) return c1; const a=hexToRgbA(c1), b=hexToRgbA(c2); const r=Math.round(lerp(a[0],b[0],t)); const g=Math.round(lerp(a[1],b[1],t)); const b2=Math.round(lerp(a[2],b[2],t)); const a2=lerp(a[3],b[3],t); return `rgba(${r},${g},${b2},${a2})`; }
    function hexToRgbA(c){ if(c.startsWith('rgba')){ const m=c.match(/rgba\((\d+),(\d+),(\d+),(.*)\)/); return [+m[1],+m[2],+m[3],+m[4]] } const ctx=document.createElement('canvas').getContext('2d'); ctx.fillStyle=c; const rgb=ctx.fillStyle; const m=rgb.match(/rgb\((\d+), (\d+), (\d+)\)/); return [+(m?.[1]||0),+(m?.[2]||0),+(m?.[3]||0),1] }

    // Landmark overlay
    function drawLandmarks(landmarks){
      octx.clearRect(0,0,els.overlay.width,els.overlay.height);
      if(!els.overlayToggle.checked) return;
      octx.fillStyle='#00e0ff';
      for(const pt of landmarks){ const p=normToCanvas(pt); octx.beginPath(); octx.arc(p.x,p.y,5,0,Math.PI*2); octx.fill(); }
    }

    // Main loop: hand tracking + hit‑testing
    let grabbed=null; let pinchClosed=false;
    function loop(){
      const t=performance.now(); updateFPS(t);
      if(els.video.readyState>=2){
        const res = handLandmarker.detectForVideo(els.video, t);
        const idx = chooseHand(res);
        const lm = (idx!=null) ? res.landmarks?.[idx] : null;
        const handedness = (idx!=null) ? res.handednesses?.[idx]?.[0]?.categoryName : null;
        if(handedness){ lastHanded=handedness.toLowerCase(); els.handed.textContent=lastHanded; }

        if(lm){
          const tipN = lm[LM.INDEX_TIP]; const thumbN = lm[LM.THUMB_TIP];
          const tip = normToCanvas(tipN);
          const pv = pinchValue(lm); // normalized space [0..~]
          const wasClosed=pinchClosed; pinchClosed = pv < 0.06; // threshold tweakable

          drawLandmarks(lm);

          // Hover state
          for(const o of scene.objects){ o.hover = o.contains(tip); }

          // Grab logic for ball
          const ball = scene.objects.find(o=>o.type==='ball');
          if(ball){
            if(!ball.isGrabbed && pinchClosed && ball.contains(tip)) { ball.isGrabbed=true; grabbed=ball; }
            if(ball.isGrabbed){ ball.x = tip.x; ball.y = tip.y; if(!pinchClosed){ ball.isGrabbed=false; grabbed=null; }
            }
          }

          // Tap detection (quick approach: transition from far->near->far within 280ms)
          const touching = scene.objects.some(o=>o.contains(tip));
          const now = performance.now();
          if(touching && !lastTouchState){ lastTouchTime = now; }
          if(!touching && lastTouchState && (now-lastTouchTime)<280){ // tap
            const target = scene.objects.find(o=>o.contains(lastTip));
            if(target && typeof target.onTap==='function' && !target.isGrabbed){ target.onTap(); }
          }
          lastTouchState = touching; lastTip = tip;
        } else {
          octx.clearRect(0,0,els.overlay.width,els.overlay.height);
          lastTouchState=false; pinchClosed=false; if(grabbed){ grabbed.isGrabbed=false; grabbed=null; }
        }
      }
      requestAnimationFrame(loop);
    }

    render();
    requestAnimationFrame(loop);

    els.overlayToggle.addEventListener('change',()=>{
      els.overlay.classList.toggle('hidden', !els.overlayToggle.checked);
    });

    els.animBtn.addEventListener('click', ()=> scene.anim=!scene.anim);
    els.resetBtn.addEventListener('click', ()=>{ scene.bg='#0c1117'; scene.targetBg='#0c1117'; scene.anim=false; const b=scene.objects.find(o=>o.type==='ball'); if(b){ b.x=180; b.y=140; } });

    const ro=new ResizeObserver(fitCanvases); ro.observe(els.stage);
  </script>
</body>
</html>
